\documentclass[document.tex]{subfiles}

\begin{document}

\section{Выпуклая оболочка}

\begin{algorithm}
	Алгоритм выпуклой оболочки в 3D за $O(N^4)$ -- полный перебор. Грани можно хранить как тройки чисел $(p_1, p_2, p_3)$, считаем, что пусть они отсортированны  так, что вектор $[p_2 - p_1, p_3 - p_2]$ сонаправел с нормалью. Перебираем все тройки точек (грани) за $O(N^3)$, и смотрим, что $[p_2 - p_1, p_3 - p_2]$ смотрит в противоположную сторону, от всех остальных точек $O(N)$. Суммарная асимптотика -- $O(N^4)$. Алгоритм обобщается на произвольную размерность, работает за $O(k^3 \cdot N^{k+1})$. Чтобы осуществить проверку, лежит ли точка снизу или сверху, считаем определитель матрицы, соответствующий гиперплоскости грани.
\end{algorithm}

\begin{algorithm}[Заворачивание подарка]
	Алгоритм заварачивания подарка за $O(N^2)$.
	\begin{enumerate}
		\item Первым делом найдём самую нижнюю точку, пусть это $p_0$.
		\item Найдем теперь точку $p_1$. Это такая точка, что у неё угол с осью $Oz$, проходящей через $p_0$, максимальный. Этот $p_0p_1$ будет в выпуклой оболочке
		\item Найдем первую грань -- перебираем все точки $p$, и находим такую, что грань, обраованная $p_0p_1p$ максимально раскрыта. Можно найти за $O(N^2)$ как в предыдущем алгоритме.

		\item Далее делаем то же самое, что и в п.3, но теперь угол между двумя соседними гранями мы знаем (это просто скалярное произведение нормалей) и искать максимально раскрытую грань можно за $O(N)$. Только нужно хранить множество ещё не просмотренных ребер ещё не построенной выпуклой оболочки и помнить, что добавление новой грани может закрывать больше 1 ребра.
	\end{enumerate}
\end{algorithm}

\begin{statement}
	$p_0p_1$ есть в выпуклой оболочке
\end{statement}

\begin{statement}
	Граней и ребер в выпуклой оболочке -- $O(N)$
\end{statement}

\begin{proof}
	Это следует из планарности графа выпуклой оболочки на сфере и формулы Эйлера для сферы: V + F = E + 2
\end{proof}

\begin{algorithm}[Разделяй и властвуй]
	Разбиваем точки по 7 в лексикографическом порядке. Строим для них выпуклые оболочки любым способом. Они не будут пересекаться для разных ``блинов''. Теперь надо научитсья объединять блины. Спроецируем эти блины на ось $xOy$. Найдем там самое правое ребро $p_0q_0$, которое есть в выпуклой оболочке проекций. От этого ребра и будем начинать строить трехмерную выпуклую оболочке объеднения блинов. Делаем также, как и в прошлом алгоритме, а именно:

	Переберем все смежные вершины с $q_0$ и $p_0$ и лежащие в выпуклой оболочке левого или правого блина соответсвенно. Строим для них грани и выбираем наилучшую. Теперь у в выпуклой оболочке блинов появилась либо новая точка $q_1$, либо $p_1$. Повторяем эти действия далее. Осталось выкинуть точки , которые лежат слева от пути $p_0p_1 \ldots p_k$, и справа от пути $q_0q_1 \ldots q_l$. Это можно сделать dfs-ом.
\end{algorithm}

\end{document}
